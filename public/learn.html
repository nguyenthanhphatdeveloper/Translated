<!DOCTYPE html>
<html lang="vi">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>H·ªçc T·ª´ V·ª±ng - English Vocabulary Learning</title>
  <script>
    // Suppress Tailwind CDN warning (ph·∫£i ƒë·∫∑t TR∆Ø·ªöC khi load Tailwind)
    const originalWarn = console.warn;
    console.warn = function (...args) {
      if (args[0] && typeof args[0] === 'string' && args[0].includes('cdn.tailwindcss.com should not be used')) {
        return; // Suppress this specific warning
      }
      originalWarn.apply(console, args);
    };
  </script>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

    * {
      font-family: 'Inter', sans-serif;
    }

    .level-badge {
      padding: 4px 10px;
      border-radius: 9999px;
      font-size: 12px;
      font-weight: 600;
      display: inline-block;
      line-height: 1;
    }

    .level-A1 {
      background: #d1fae5;
      color: #065f46;
    }

    .level-A2 {
      background: #dbeafe;
      color: #1d4ed8;
    }

    .level-B1 {
      background: #fef9c3;
      color: #92400e;
    }

    .level-B2 {
      background: #ffedd5;
      color: #9a3412;
    }

    .level-C1 {
      background: #fee2e2;
      color: #b91c1c;
    }

    .level-C2 {
      background: #ede9fe;
      color: #6d28d9;
    }

    .word-card {
      transition: all 0.3s ease;
    }

    .word-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
    }

    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }

    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    @media (max-width: 640px) {
      .nav-links {
        gap: 8px;
        padding: 8px 0 6px;
      }

      .nav-links a {
        white-space: nowrap;
        padding: 8px 10px;
        border-radius: 9999px;
        background: #f9fafb;
      }

      .nav-links a.active-nav {
        background: #ede9fe;
        color: #5b21b6;
        font-weight: 600;
      }
    }
  </style>
</head>

<body class="bg-gray-50 min-h-screen">
  <!-- Navigation -->
  <script src="/js/header.js"></script>

  <!-- Main Content -->
  <div class="max-w-7xl mx-auto px-3 sm:px-4 md:px-6 lg:px-8 py-4 sm:py-6 md:py-8">
    <!-- Header -->
    <div class="mb-4 sm:mb-6 md:mb-8">
      <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-gray-900 mb-1 sm:mb-2">H·ªçc T·ª´ V·ª±ng M·ªõi</h1>
      <p class="text-xs sm:text-sm text-gray-600">Ch·ªçn level v√† b·∫Øt ƒë·∫ßu h·ªçc t·ª´ v·ª±ng ti·∫øng Anh</p>
    </div>

    <!-- Filters -->
    <div class="bg-white rounded-lg shadow p-3 sm:p-4 md:p-6 mb-4 sm:mb-6">
      <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3 sm:gap-4">
        <div>
          <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-1.5 sm:mb-2">C·∫•p ƒë·ªô</label>
          <select id="levelFilter"
            class="w-full px-3 sm:px-4 py-2.5 sm:py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-sm sm:text-base"
            onchange="handleLevelChange()">
            <option value="">T·∫•t c·∫£</option>
            <option value="A1">A1 - Beginner</option>
            <option value="A2">A2 - Elementary</option>
            <option value="B1">B1 - Intermediate</option>
            <option value="B2">B2 - Upper Intermediate</option>
            <option value="C1">C1 - Advanced</option>
            <option value="C2">C2 - Proficient</option>
          </select>
        </div>
        <div>
          <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-1.5 sm:mb-2">T√¨m ki·∫øm</label>
          <input type="text" id="searchInput" placeholder="Nh·∫≠p t·ª´ c·∫ßn t√¨m..."
            class="w-full px-3 sm:px-4 py-2.5 sm:py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-sm sm:text-base">
        </div>
        <div>
          <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-1.5 sm:mb-2">Ch·ªß ƒë·ªÅ</label>
          <select id="topicFilter"
            class="w-full px-3 sm:px-4 py-2.5 sm:py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-sm sm:text-base">
            <option value="">T·∫•t c·∫£ ch·ªß ƒë·ªÅ</option>
          </select>
        </div>
        <div>
          <label class="block text-xs sm:text-sm font-medium text-gray-700 mb-1.5 sm:mb-2">S·ªë t·ª´ hi·ªÉn th·ªã</label>
          <select id="limitSelect"
            class="w-full px-3 sm:px-4 py-2.5 sm:py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-sm sm:text-base">
            <option value="20">20 t·ª´</option>
            <option value="50" selected>50 t·ª´</option>
            <option value="100">100 t·ª´</option>
          </select>
        </div>
      </div>
      <button onclick="loadWords()"
        class="mt-3 sm:mt-4 w-full sm:w-auto px-4 sm:px-6 py-2.5 sm:py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition text-sm sm:text-base font-medium min-h-[44px] sm:min-h-0">
        <i class="fas fa-search mr-2"></i>T√¨m ki·∫øm
      </button>
    </div>

    <!-- Stats -->
    <div id="stats" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-6 gap-2 sm:gap-3 md:gap-4 mb-4 sm:mb-6">
      <!-- Stats will be loaded here -->
    </div>
    <div id="topTopics"
      class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-2 sm:gap-3 mb-4 sm:mb-6"></div>

    <!-- Word List -->
    <div id="wordList" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4">
      <!-- Words will be loaded here -->
    </div>

    <!-- Loading -->
    <div id="loading" class="text-center py-12 hidden">
      <i class="fas fa-spinner fa-spin text-4xl text-purple-600"></i>
      <p class="mt-4 text-gray-600">ƒêang t·∫£i...</p>
    </div>

    <!-- Pagination -->
    <div id="pagination" class="mt-8 flex justify-center">
      <!-- Pagination will be loaded here -->
    </div>
  </div>

  <!-- Word Detail Modal -->
  <div id="wordModal"
    class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center p-2 sm:p-4">
    <div class="bg-white rounded-lg max-w-2xl w-full max-h-[95vh] sm:max-h-[90vh] overflow-y-auto flex flex-col">
      <div class="sticky top-0 bg-white border-b p-3 sm:p-4 flex justify-between items-center z-10">
        <h2 id="modalWord" class="text-lg sm:text-xl md:text-2xl font-bold"></h2>
        <button onclick="closeModal()" class="text-gray-500 hover:text-gray-700 p-1 sm:p-2">
          <i class="fas fa-times text-xl sm:text-2xl"></i>
        </button>
      </div>
      <!-- Tabs -->
      <div class="border-b bg-white sticky top-[60px] sm:top-16 z-10">
        <div class="flex gap-1 sm:gap-2 px-2 sm:px-4">
          <button id="tabDetails" onclick="showWordTab('details')"
            class="px-3 sm:px-4 py-2 border-b-2 border-purple-600 text-purple-600 font-medium transition-colors text-xs sm:text-sm">
            Chi ti·∫øt
          </button>
          <button id="tabAI" onclick="showWordTab('ai')"
            class="px-3 sm:px-4 py-2 border-b-2 border-transparent text-gray-600 hover:text-purple-600 font-medium transition-colors text-xs sm:text-sm">
            <i class="fas fa-robot mr-1"></i>AI Gi·∫£i th√≠ch
          </button>
        </div>
      </div>
      <div id="modalContent" class="p-3 sm:p-4 md:p-6 flex-1 overflow-y-auto">
        <!-- Word details will be loaded here -->
      </div>
    </div>
  </div>

  <script src="https://js.puter.com/v2/"></script>
  <script src="/js/vocabulary.js"></script>
  <script src="/js/storage.js"></script>
  <script src="/js/command.js"></script>
  <script>
    const storage = new StorageManager();
    const DICT_CACHE_KEY = 'dictionary_cache_v1';
    const AI_CACHE_KEY = 'ai_explanation_cache_v1';
    let dictionaryCache = loadDictCache();
    let aiCache = loadAICache();
    let currentPage = 1;
    let currentFilters = {};
    let currentWordData = null; // L∆∞u word data hi·ªán t·∫°i
    let currentTab = 'details'; // 'details' ho·∫∑c 'ai'

    function loadDictCache() {
      try {
        const cached = localStorage.getItem(DICT_CACHE_KEY);
        return cached ? JSON.parse(cached) : {};
      } catch (e) {
        console.warn('Cannot load dictionary cache:', e);
        return {};
      }
    }

    function saveDictCache() {
      try {
        localStorage.setItem(DICT_CACHE_KEY, JSON.stringify(dictionaryCache));
      } catch (e) {
        console.warn('Cannot save dictionary cache:', e);
      }
    }

    function loadAICache() {
      try {
        const cached = localStorage.getItem(AI_CACHE_KEY);
        return cached ? JSON.parse(cached) : {};
      } catch (e) {
        console.warn('Cannot load AI cache:', e);
        return {};
      }
    }

    function saveAICache() {
      try {
        localStorage.setItem(AI_CACHE_KEY, JSON.stringify(aiCache));
      } catch (e) {
        console.warn('Cannot save AI cache:', e);
      }
    }

    // Ki·ªÉm tra Puter.js availability
    function checkPuterAvailable() {
      if (typeof Puter !== 'undefined' && Puter.ai && Puter.ai.chat) {
        return Puter;
      }
      if (typeof puter !== 'undefined' && puter.ai && puter.ai.chat) {
        return puter;
      }
      if (typeof window.puter !== 'undefined' && window.puter.ai && window.puter.ai.chat) {
        return window.puter;
      }
      return null;
    }

    // Switch tabs
    function showWordTab(tab) {
      currentTab = tab;

      // Update tab buttons
      const tabDetails = document.getElementById('tabDetails');
      const tabAI = document.getElementById('tabAI');

      if (tab === 'details') {
        tabDetails.classList.add('border-purple-600', 'text-purple-600');
        tabDetails.classList.remove('border-transparent', 'text-gray-600');
        tabAI.classList.remove('border-purple-600', 'text-purple-600');
        tabAI.classList.add('border-transparent', 'text-gray-600');

        // Show details content
        renderWordDetails();
      } else {
        tabDetails.classList.remove('border-purple-600', 'text-purple-600');
        tabDetails.classList.add('border-transparent', 'text-gray-600');
        tabAI.classList.add('border-purple-600', 'text-purple-600');
        tabAI.classList.remove('border-transparent', 'text-gray-600');

        // Show AI content
        renderAIContent();
      }
    }

    // Render word details (existing content)
    function renderWordDetails() {
      if (!currentWordData) return;

      const modalContent = document.getElementById('modalContent');
      const { word, wordData, dictData } = currentWordData;

      let html = `
        <div class="space-y-4">
          <div class="flex items-center space-x-4">
            <span class="level-badge level-${wordData.Level}">${wordData.Level}</span>
            <span class="text-gray-600">${wordData['Part of Speech'] || 'N/A'}</span>
            ${wordData.Topic ? `<span class="text-gray-600"><i class="fas fa-folder mr-1"></i>${wordData.Topic}</span>` : ''}
          </div>
          ${wordData.Guideword ? `<p class="text-gray-600"><strong>Guideword:</strong> ${wordData.Guideword}</p>` : ''}
          ${wordData.Translate ? `<p class="text-purple-600 font-medium"><strong>Nghƒ©a:</strong> ${wordData.Translate}</p>` : ''}
      `;

      if (dictData) {
        // Pronunciation
        if (dictData.pronunciation && dictData.pronunciation.length > 0) {
          html += `
            <div class="border-t pt-4">
              <h3 class="font-semibold mb-2">Ph√°t √¢m (IPA)</h3>
              ${dictData.pronunciation.map(pron => `
                <div class="flex items-center space-x-2 mb-2">
                  <span class="px-2 py-1 bg-purple-50 text-purple-700 rounded text-xs font-semibold">${(pron.lang || '').toUpperCase() || 'US'}</span>
                  <span class="text-gray-800 font-mono">${pron.pron || ''}</span>
                  ${pron.url ? `<audio controls class="h-8"><source src="${pron.url}" type="audio/mpeg"></audio>` : ''}
                </div>
              `).join('')}
            </div>
          `;
        }

        // Definitions
        if (dictData.definition && dictData.definition.length > 0) {
          html += `
            <div class="border-t pt-4">
              <h3 class="font-semibold mb-2">ƒê·ªãnh nghƒ©a</h3>
              ${dictData.definition.map(def => `
                <div class="mb-4">
                  <p class="text-gray-700 mb-1">${def.text}</p>
                  ${def.translation ? `<p class="text-gray-600 italic">${def.translation}</p>` : ''}
                  ${def.example && def.example.length > 0 ? `
                    <div class="mt-2 ml-4 border-l-2 border-purple-200 pl-3">
                      ${def.example.map(ex => `
                        <p class="text-sm text-gray-600 mb-1">${ex.text}</p>
                        ${ex.translation ? `<p class="text-sm text-gray-500 italic">${ex.translation}</p>` : ''}
                      `).join('')}
                    </div>
                  ` : ''}
                </div>
              `).join('')}
            </div>
          `;
        }
      } else {
        html += `<p class="text-gray-500">Kh√¥ng t√¨m th·∫•y th√¥ng tin chi ti·∫øt t·ª´ Cambridge Dictionary</p>`;
      }

      html += `</div>`;
      modalContent.innerHTML = html;
    }

    // Render AI content
    function renderAIContent() {
      const modalContent = document.getElementById('modalContent');

      if (!currentWordData) {
        modalContent.innerHTML = '<p class="text-gray-500">Vui l√≤ng ch·ªçn tab "Chi ti·∫øt" tr∆∞·ªõc</p>';
        return;
      }

      const { word, wordData } = currentWordData;

      // Check cache first
      const cacheKey = `${word}_${wordData.Level}`;
      if (aiCache[cacheKey]) {
        const cachedResponse = aiCache[cacheKey];
        // ƒê·∫£m b·∫£o cached response l√† string v√† c√≥ n·ªôi dung
        if (typeof cachedResponse === 'string' && cachedResponse.length > 10) {
          modalContent.innerHTML = formatAIResponse(cachedResponse);
          // Hi·ªÉn th·ªã indicator l√† cached
          const cachedBadge = '<div class="mb-2 text-xs text-green-600 bg-green-50 px-2 py-1 rounded inline-block"><i class="fas fa-bolt"></i> T·ª´ cache (instant)</div>';
          modalContent.insertAdjacentHTML('afterbegin', cachedBadge);
          return;
        } else {
          // N·∫øu cache kh√¥ng ƒë√∫ng format, x√≥a v√† fetch l·∫°i
          delete aiCache[cacheKey];
          saveAICache();
        }
      }

      // Check Puter.js availability
      const puterClient = checkPuterAvailable();
      if (!puterClient) {
        modalContent.innerHTML = `
          <div class="text-center py-8">
            <i class="fas fa-robot text-4xl text-gray-400 mb-4"></i>
            <p class="text-gray-600 mb-2">Puter.js kh√¥ng kh·∫£ d·ª•ng</p>
            <p class="text-sm text-gray-500 mb-4">Vui l√≤ng ƒëƒÉng nh·∫≠p t·∫°i <a href="https://puter.com" target="_blank" class="text-purple-600 hover:underline">puter.com</a> ƒë·ªÉ s·ª≠ d·ª•ng t√≠nh nƒÉng AI</p>
            <p class="text-xs text-gray-400">Ho·∫∑c s·ª≠ d·ª•ng tab "Chi ti·∫øt" ƒë·ªÉ xem th√¥ng tin t·ª´ Cambridge Dictionary</p>
          </div>
        `;
        return;
      }

      // Show loading with better UX v√† timer
      let loadingSeconds = 0;
      const loadingInterval = setInterval(() => {
        loadingSeconds++;
        const timerEl = document.getElementById('aiLoadingTimer');
        if (timerEl) {
          timerEl.textContent = `ƒê√£ ch·ªù ${loadingSeconds} gi√¢y...`;
        }
      }, 1000);

      modalContent.innerHTML = `
        <div class="text-center py-8">
          <i class="fas fa-spinner fa-spin text-4xl text-purple-600 mb-4"></i>
          <p class="text-gray-600 mb-2">ƒêang t·∫£i gi·∫£i th√≠ch t·ª´ AI...</p>
          <p id="aiLoadingTimer" class="text-sm text-gray-500 mb-2">ƒê√£ ch·ªù 0 gi√¢y...</p>
          <p class="text-xs text-gray-400 mb-4">Th∆∞·ªùng m·∫•t 3-5 gi√¢y</p>
          <div class="mt-4 w-full bg-gray-200 rounded-full h-2 overflow-hidden">
            <div class="bg-purple-600 h-2 rounded-full animate-pulse" style="width: 60%"></div>
          </div>
        </div>
      `;

      // Store interval ƒë·ªÉ clear sau
      window.aiLoadingInterval = loadingInterval;

      loadAIExplanation(word, wordData.Level, cacheKey).finally(() => {
        if (window.aiLoadingInterval) {
          clearInterval(window.aiLoadingInterval);
          window.aiLoadingInterval = null;
        }
      });
    }

    // Load AI explanation
    async function loadAIExplanation(word, level, cacheKey) {
      const modalContent = document.getElementById('modalContent');
      const puterClient = checkPuterAvailable();

      if (!puterClient) {
        modalContent.innerHTML = '<p class="text-red-500">Puter.js kh√¥ng kh·∫£ d·ª•ng</p>';
        return;
      }

      // Set timeout ƒë·ªÉ tr√°nh ch·ªù qu√° l√¢u (tƒÉng l√™n 15 gi√¢y v√¨ c√≥ th·ªÉ c·∫ßn th·ªùi gian)
      const timeoutId = setTimeout(() => {
        const timerEl = document.getElementById('aiLoadingTimer');
        if (timerEl) {
          timerEl.innerHTML = '<span class="text-yellow-600">ƒêang x·ª≠ l√Ω, vui l√≤ng ƒë·ª£i th√™m...</span>';
        }
      }, 10000);

      try {
        // Prompt theo y√™u c·∫ßu: 1. Nghƒ©a, 2. IPA, 3. √Çm nh·∫•n, 4. √Çm ti·∫øt, 5. T·ª´ lo·∫°i li√™n quan, 6. Collocations
        const prompt = `Gi·∫£i th√≠ch t·ª´ "${word}" (${level}) theo th·ª© t·ª±: 1. Nghƒ©a, 2. IPA, 3. √Çm nh·∫•n, 4. √Çm ti·∫øt, 5. T·ª´ lo·∫°i li√™n quan, 6. Collocations. D√πng emoji, kh√¥ng markdown.`;

        // Th√™m options ƒë·ªÉ t·ªëi ∆∞u t·ªëc ƒë·ªô
        const startTime = Date.now();

        // T·∫°o chat promise v·ªõi timeout protection
        let response;

        // T·∫°o chat promise v·ªõi th·ª≠ nhi·ªÅu model (t·ª´ nhanh nh·∫•t ƒë·∫øn ch·∫≠m nh·∫•t)
        const chatPromise = (async () => {
          // Danh s√°ch model ƒë·ªÉ th·ª≠ (theo th·ª© t·ª± ∆∞u ti√™n: nhanh ‚Üí ch·∫≠m)
          const modelsToTry = [
            "gpt-4o-mini",      // ƒê√£ test: ~14-16s (nhanh h∆°n gpt-5-nano)
            "gpt-3.5-turbo",    // Model nhanh c·ªßa OpenAI (c√≥ th·ªÉ nhanh h∆°n)
            "gpt-5-mini",       // Nhanh nh·∫•t (theo web search, nh∆∞ng c√≥ th·ªÉ kh√¥ng c√≥ s·∫µn)
            "gpt-5-nano",       // Model c≈© (~18-20s)
            "gpt-4o",           // Fallback cu·ªëi c√πng
          ];

          for (const model of modelsToTry) {
            try {
              // Th·ª≠ v·ªõi max_tokens ƒë·ªÉ gi·ªõi h·∫°n ƒë·ªô d√†i response (nhanh h∆°n)
              try {
                const result = await puterClient.ai.chat(prompt, {
                  model: model,
                  max_tokens: 120 // Gi·∫£m xu·ªëng 120 ƒë·ªÉ nhanh h∆°n (thay v√¨ 150)
                });
                console.log(`‚úÖ Success with model: ${model}`);
                return result;
              } catch (optionsError) {
                // N·∫øu max_tokens kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£, th·ª≠ kh√¥ng c√≥ options
                if (optionsError && typeof optionsError === 'object') {
                  if (optionsError.success === false || optionsError.error) {
                    const errorMsg = optionsError.error?.message || optionsError.error?.code || '';
                    // N·∫øu l√† l·ªói "model not found", th·ª≠ model ti·∫øp theo
                    if (errorMsg.includes('model') && (errorMsg.includes('not found') || errorMsg.includes('not available'))) {
                      console.log(`‚ö†Ô∏è Model ${model} not available, trying next...`);
                      continue; // Th·ª≠ model ti·∫øp theo
                    }
                    // N·∫øu l√† l·ªói v·ªÅ options (nh∆∞ temperature), th·ª≠ kh√¥ng c√≥ options
                    if (errorMsg.includes('temperature') || errorMsg.includes('max_tokens')) {
                      console.log(`‚ö†Ô∏è Options not supported for ${model}, trying without options...`);
                      // Th·ª≠ kh√¥ng c√≥ options
                      try {
                        const result = await puterClient.ai.chat(prompt, { model: model });
                        console.log(`‚úÖ Success with model: ${model} (no options)`);
                        return result;
                      } catch (noOptionsError) {
                        // N·∫øu v·∫´n l·ªói, th·ª≠ model ti·∫øp theo
                        continue;
                      }
                    }
                  }
                }
                // N·∫øu kh√¥ng ph·∫£i l·ªói model, throw l·∫°i
                throw optionsError;
              }
            } catch (modelError) {
              // N·∫øu l√† l·ªói "model not found", th·ª≠ model ti·∫øp theo
              if (modelError && typeof modelError === 'object') {
                const errorMsg = modelError.error?.message || modelError.error?.code || modelError.message || '';
                if (errorMsg.includes('model') && (errorMsg.includes('not found') || errorMsg.includes('not available'))) {
                  console.log(`‚ö†Ô∏è Model ${model} not available, trying next...`);
                  continue; // Th·ª≠ model ti·∫øp theo
                }
              }
              // N·∫øu l√† l·ªói kh√°c v√† ƒë√¢y l√† model cu·ªëi c√πng, throw
              if (model === modelsToTry[modelsToTry.length - 1]) {
                throw modelError;
              }
              // N·∫øu kh√¥ng ph·∫£i model cu·ªëi, th·ª≠ model ti·∫øp theo
              continue;
            }
          }

          // N·∫øu t·∫•t c·∫£ model ƒë·ªÅu fail, throw error
          throw new Error('All models failed. Please check Puter.js availability.');
        })();

        // Timeout promise: reject sau 30 gi√¢y (tƒÉng l√™n v√¨ model c√≥ th·ªÉ c·∫ßn 18-20s)
        const timeoutPromise = new Promise((_, reject) => {
          setTimeout(() => {
            reject(new Error('Request timeout after 30 seconds'));
          }, 30000);
        });

        // Race gi·ªØa chat v√† timeout
        try {
          response = await Promise.race([chatPromise, timeoutPromise]);
        } catch (raceError) {
          // N·∫øu timeout, throw timeout error
          if (raceError.message && raceError.message.includes('timeout')) {
            throw raceError;
          }
          // N·∫øu l√† l·ªói kh√°c t·ª´ chat, throw l·∫°i
          throw raceError;
        }

        const responseTime = Date.now() - startTime;
        console.log(`‚úÖ AI response time: ${responseTime}ms (${(responseTime / 1000).toFixed(1)}s)`);

        // Warn n·∫øu qu√° ch·∫≠m (ƒëi·ªÅu ch·ªânh threshold: 12s cho gpt-4o-mini)
        if (responseTime > 12000) {
          console.warn(`‚ö†Ô∏è AI response qu√° ch·∫≠m (${(responseTime / 1000).toFixed(1)}s). C√≥ th·ªÉ do network ho·∫∑c Puter.js server.`);
        } else if (responseTime > 8000) {
          console.info(`‚ÑπÔ∏è AI response time: ${(responseTime / 1000).toFixed(1)}s (ch·∫•p nh·∫≠n ƒë∆∞·ª£c)`);
        }

        // Clear timeout v√† loading interval
        clearTimeout(timeoutId);
        if (window.aiLoadingInterval) {
          clearInterval(window.aiLoadingInterval);
          window.aiLoadingInterval = null;
        }

        // Ki·ªÉm tra response type (Puter.js format: response.message.content)
        let responseText = '';
        if (typeof response === 'string') {
          responseText = response;
        } else if (response && typeof response === 'object') {
          // Puter.js format: response.message.content
          if (response.message && response.message.content) {
            responseText = response.message.content;
          }
          // OpenAI format: response.choices[0].message.content
          else if (response.choices && response.choices[0] && response.choices[0].message && response.choices[0].message.content) {
            responseText = response.choices[0].message.content;
          }
          // C√°c format kh√°c
          else {
            responseText = response.text || response.content || response.message || response.response || '';
          }

          // N·∫øu v·∫´n kh√¥ng c√≥, log ƒë·ªÉ debug
          if (!responseText || responseText === '{}' || responseText === '[object Object]') {
            console.warn('Unexpected AI response format:', response);
            // N·∫øu c√≥ message object, th·ª≠ l·∫•y content t·ª´ ƒë√≥
            if (response.message && typeof response.message === 'object') {
              responseText = response.message.content || response.message.text || 'Xin l·ªói, kh√¥ng th·ªÉ x·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ AI.';
            } else {
              responseText = 'Xin l·ªói, kh√¥ng th·ªÉ x·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ AI. Vui l√≤ng th·ª≠ l·∫°i.';
            }
          }
        } else {
          responseText = String(response || 'Kh√¥ng c√≥ ph·∫£n h·ªìi');
        }

        // ƒê·∫£m b·∫£o responseText l√† string
        if (typeof responseText !== 'string') {
          responseText = String(responseText);
        }

        // Cache response (ch·ªâ cache string)
        if (typeof responseText === 'string' && responseText.length > 0) {
          aiCache[cacheKey] = responseText;
          saveAICache();
        }

        // Display formatted response
        modalContent.innerHTML = formatAIResponse(responseText);
      } catch (error) {
        clearTimeout(timeoutId);
        if (window.aiLoadingInterval) {
          clearInterval(window.aiLoadingInterval);
          window.aiLoadingInterval = null;
        }

        console.error('AI explanation error:', error);

        let errorMessage = 'Vui l√≤ng th·ª≠ l·∫°i sau';
        let isTimeout = false;

        if (error.message) {
          errorMessage = error.message;
          if (error.message.includes('timeout')) {
            isTimeout = true;
            errorMessage = 'AI ph·∫£n h·ªìi qu√° ch·∫≠m (>30 gi√¢y). C√≥ th·ªÉ do network ho·∫∑c server Puter.js.';
          }
        } else if (typeof error === 'string') {
          errorMessage = error;
        }

        modalContent.innerHTML = `
          <div class="text-center py-8">
            <i class="fas fa-${isTimeout ? 'clock' : 'exclamation-triangle'} text-4xl text-${isTimeout ? 'yellow' : 'red'}-400 mb-4"></i>
            <p class="text-${isTimeout ? 'yellow' : 'red'}-600 mb-2 font-semibold">
              ${isTimeout ? 'Ph·∫£n h·ªìi qu√° ch·∫≠m' : 'L·ªói khi t·∫£i gi·∫£i th√≠ch t·ª´ AI'}
            </p>
            <p class="text-sm text-gray-500 mb-2">${errorMessage}</p>
            ${isTimeout ? `
              <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 mb-4 text-left text-sm max-w-md mx-auto">
                <p class="font-semibold text-yellow-800 mb-1">üí° G·ª£i √Ω:</p>
                <ul class="list-disc list-inside text-yellow-700 space-y-1">
                  <li>S·ª≠ d·ª•ng tab "Chi ti·∫øt" ƒë·ªÉ xem th√¥ng tin t·ª´ Cambridge Dictionary (nhanh h∆°n)</li>
                  <li>Th·ª≠ l·∫°i sau v√†i ph√∫t (c√≥ th·ªÉ server ƒëang b·∫≠n)</li>
                  <li>Ki·ªÉm tra k·∫øt n·ªëi internet</li>
                </ul>
              </div>
            ` : ''}
            <p class="text-xs text-gray-400 mb-4">Ki·ªÉm tra Console (F12) ƒë·ªÉ xem chi ti·∫øt</p>
            <div class="flex gap-2 justify-center">
              <button onclick="renderAIContent()" class="px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700">
                Th·ª≠ l·∫°i
              </button>
              <button onclick="showWordTab('details')" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">
                Xem Chi ti·∫øt
              </button>
            </div>
          </div>
        `;
      }
    }

    // Format AI response to HTML
    function formatAIResponse(text) {
      // Ki·ªÉm tra input type
      if (!text) {
        return '<p class="text-gray-500">Kh√¥ng c√≥ d·ªØ li·ªáu</p>';
      }

      // ƒê·∫£m b·∫£o text l√† string
      let textStr = '';
      if (typeof text === 'string') {
        textStr = text;
      } else if (typeof text === 'object') {
        // N·∫øu l√† object, th·ª≠ extract text
        textStr = text.text || text.content || text.message || text.response || JSON.stringify(text);
      } else {
        textStr = String(text);
      }

      if (!textStr || textStr.trim().length === 0) {
        return '<p class="text-gray-500">Kh√¥ng c√≥ d·ªØ li·ªáu</p>';
      }

      // Escape HTML ƒë·ªÉ tr√°nh XSS
      const escapeHtml = (str) => {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
      };

      // Split by double newlines (paragraphs)
      const paragraphs = textStr.split(/\n\n+/).filter(p => p.trim());

      if (paragraphs.length === 0) {
        // N·∫øu kh√¥ng c√≥ paragraph, split by single newline
        const lines = textStr.split(/\n/).filter(l => l.trim());
        if (lines.length === 0) {
          return `<p class="text-gray-700">${escapeHtml(textStr)}</p>`;
        }
        paragraphs.push(...lines);
      }

      let html = '<div class="space-y-4">';

      paragraphs.forEach(para => {
        const trimmed = para.trim();
        if (!trimmed) return;

        // Check if it's a heading (starts with number or emoji + text)
        if (/^[\d\s]*[üéØüìöüí°üî§‚ú®üìù]/i.test(trimmed) || /^\d+\./.test(trimmed)) {
          html += `<h3 class="font-semibold text-lg text-purple-700 mt-4 mb-2">${escapeHtml(trimmed)}</h3>`;
        }
        // Check if it's a list item
        else if (/^[-‚Ä¢‚ñ™‚ñ´]\s/.test(trimmed) || /^\d+[\.\)]\s/.test(trimmed)) {
          html += `<div class="ml-4 mb-2 text-gray-700">${escapeHtml(trimmed)}</div>`;
        }
        // Regular paragraph
        else {
          // Replace **bold** with <strong> (sau khi escape)
          const escaped = escapeHtml(trimmed);
          const formatted = escaped
            .replace(/\*\*(.*?)\*\*/g, '<strong class="text-gray-900 font-semibold">$1</strong>')
            .replace(/\*(.*?)\*/g, '<em class="text-gray-700 italic">$1</em>');

          html += `<p class="text-gray-700 leading-relaxed">${formatted}</p>`;
        }
      });

      html += '</div>';

      return html;
    }

    // Load words on page load
    window.addEventListener('DOMContentLoaded', () => {
      loadStats();
      loadTopics();
      loadTopTopics();
      loadWords();
    });

    function handleLevelChange() {
      const level = document.getElementById('levelFilter').value;
      loadTopics(level);
      loadTopTopics(level);
    }

    // Load statistics
    async function loadStats() {
      try {
        const response = await fetch('/api/vocabulary/stats');
        const stats = await response.json();

        const statsHtml = `
          <div class="bg-white rounded-lg shadow p-4 text-center">
            <div class="text-2xl font-bold text-gray-900">${stats.total.toLocaleString()}</div>
            <div class="text-sm text-gray-600">T·ªïng s·ªë t·ª´</div>
          </div>
          ${['A1', 'A2', 'B1', 'B2', 'C1', 'C2'].map(level => `
            <div class="bg-white rounded-lg shadow p-4 text-center">
              <div class="text-xl font-bold level-${level}">${stats.byLevel[level] || 0}</div>
              <div class="text-xs text-gray-600 mt-1">Level ${level}</div>
            </div>
          `).join('')}
        `;
        document.getElementById('stats').innerHTML = statsHtml;
      } catch (error) {
        console.error('Error loading stats:', error);
      }
    }

    // Load words
    async function loadWords(page = 1) {
      const loading = document.getElementById('loading');
      const wordList = document.getElementById('wordList');

      loading.classList.remove('hidden');
      wordList.innerHTML = '';

      const level = document.getElementById('levelFilter').value;
      const search = document.getElementById('searchInput').value;
      const topic = document.getElementById('topicFilter').value;
      const limit = document.getElementById('limitSelect').value;

      currentFilters = { level, search, topic, limit, page };

      try {
        const params = new URLSearchParams({
          page,
          limit,
          ...(level && { level }),
          ...(topic && { topic }),
          ...(search && { search })
        });

        const response = await fetch(`/api/vocabulary/words?${params}`);
        const data = await response.json();

        if (data.data.length === 0) {
          wordList.innerHTML = '<div class="col-span-full text-center py-12 text-gray-500">Kh√¥ng t√¨m th·∫•y t·ª´ n√†o</div>';
        } else {
          wordList.innerHTML = data.data.map((word, index) => {
            const progress = storage.getWordProgress(word['Base Word']);
            const isLearned = progress && progress.status !== 'learning';

            return `
              <div class="word-card bg-white rounded-lg shadow p-6 cursor-pointer" onclick="showWordDetail('${word['Base Word']}', ${data.pagination.page * data.pagination.limit - data.pagination.limit + index})">
                <div class="flex justify-between items-start mb-3">
                  <h3 class="text-xl font-bold text-gray-900">${word['Base Word']}</h3>
                  <span class="level-badge level-${word.Level}">${word.Level}</span>
                </div>
                ${word.Guideword ? `<p class="text-sm text-gray-600 mb-2">${word.Guideword}</p>` : ''}
                ${word.Translate ? `<p class="text-sm text-purple-600 mb-2 font-medium">${word.Translate}</p>` : ''}
                <p class="text-sm text-gray-500 mb-3">
                  <i class="fas a-tag mr-1"></i>${word['Part of Speech'] || 'N/A'}
                  ${word.Topic ? `<span class="ml-2"><i class="fas fa-folder mr-1"></i>${word.Topic}</span>` : ''}
                </p>
                ${isLearned ? '<span class="text-green-600 text-sm"><i class="fas fa-check-circle mr-1"></i>ƒê√£ h·ªçc</span>' : ''}
                <button onclick="event.stopPropagation(); markAsLearned('${word['Base Word']}', ${data.pagination.page * data.pagination.limit - data.pagination.limit + index})" 
                  class="mt-3 w-full px-4 py-2 bg-purple-100 text-purple-700 rounded-lg hover:bg-purple-200 transition text-sm">
                  <i class="fas fa-bookmark mr-2"></i>ƒê√°nh d·∫•u ƒë√£ h·ªçc
                </button>
              </div>
            `;
          }).join('');

          // Pagination
          if (data.pagination.totalPages > 1) {
            const paginationHtml = `
              <div class="flex items-center space-x-2">
                <button onclick="loadWords(${page - 1})" ${page === 1 ? 'disabled' : ''} 
                  class="px-4 py-2 border rounded-lg ${page === 1 ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-50'}">
                  <i class="fas fa-chevron-left"></i>
                </button>
                <span class="px-4 py-2">Trang ${page} / ${data.pagination.totalPages}</span>
                <button onclick="loadWords(${page + 1})" ${page === data.pagination.totalPages ? 'disabled' : ''} 
                  class="px-4 py-2 border rounded-lg ${page === data.pagination.totalPages ? 'opacity-50 cursor-not-allowed' : 'hover:bg-gray-50'}">
                  <i class="fas fa-chevron-right"></i>
                </button>
              </div>
            `;
            document.getElementById('pagination').innerHTML = paginationHtml;
          }
        }
      } catch (error) {
        console.error('Error loading words:', error);
        wordList.innerHTML = '<div class="col-span-full text-center py-12 text-red-500">L·ªói khi t·∫£i d·ªØ li·ªáu</div>';
      } finally {
        loading.classList.add('hidden');
      }
    }

    // Load topics (optionally by level)
    async function loadTopics(level = '') {
      const topicSelect = document.getElementById('topicFilter');
      topicSelect.innerHTML = '<option value="">T·∫•t c·∫£ ch·ªß ƒë·ªÅ</option>';
      try {
        const params = level ? `?level=${level}` : '';
        const res = await fetch(`/api/vocabulary/topics${params}`);
        const data = await res.json();
        (data.data || []).forEach(item => {
          const opt = document.createElement('option');
          opt.value = item.topic;
          opt.textContent = `${item.topic} (${item.count})`;
          topicSelect.appendChild(opt);
        });
      } catch (e) {
        console.error('Error loading topics:', e);
      }
    }

    // Load top topics for selected level
    async function loadTopTopics(level = '') {
      const container = document.getElementById('topTopics');
      container.innerHTML = '';
      try {
        const params = level ? `?level=${level}` : '';
        const res = await fetch(`/api/vocabulary/topics${params}`);
        const data = await res.json();
        const topics = (data.data || []).slice(0, 8);
        container.innerHTML = topics.map(t => `
          <div class="bg-white rounded-lg shadow p-3 flex items-center justify-between">
            <span class="text-sm text-gray-800">${t.topic}</span>
            <span class="text-xs font-semibold text-purple-700 bg-purple-50 px-2 py-1 rounded">${t.count}</span>
          </div>
        `).join('') || '<div class="text-sm text-gray-500">Kh√¥ng c√≥ ch·ªß ƒë·ªÅ</div>';
      } catch (e) {
        console.error('Error loading top topics:', e);
      }
    }

    // Mark word as learned
    function markAsLearned(word, index) {
      // Get word data from API
      fetch(`/api/vocabulary/words/${index}`)
        .then(res => res.json())
        .then(wordData => {
          storage.updateWordProgress(word, wordData, 'learning');
          loadWords(currentFilters.page);
          alert(`ƒê√£ ƒë√°nh d·∫•u "${word}" l√† t·ª´ ƒë√£ h·ªçc!`);
        })
        .catch(error => {
          console.error('Error:', error);
          alert('C√≥ l·ªói x·∫£y ra');
        });
    }

    // Show word detail modal
    async function showWordDetail(word, index) {
      const modal = document.getElementById('wordModal');
      const modalWord = document.getElementById('modalWord');
      const modalContent = document.getElementById('modalContent');

      modalWord.textContent = word;
      modalContent.innerHTML = '<div class="text-center py-8"><i class="fas fa-spinner fa-spin text-4xl text-purple-600"></i></div>';
      modal.classList.remove('hidden');
      currentTab = 'details'; // Reset to details tab

      try {
        // Get word data
        const wordRes = await fetch(`/api/vocabulary/words/${index}`);
        const wordData = await wordRes.json();

        // Get Cambridge Dictionary details (use cache first)
        let dictData = dictionaryCache[word];
        if (!dictData) {
          const dictRes = await fetch(`/api/dictionary/en/${encodeURIComponent(word)}`);
          if (dictRes.ok) {
            dictData = await dictRes.json();
            dictionaryCache[word] = dictData;
            saveDictCache();
          }
        }

        // Store current word data for tab switching
        currentWordData = { word, wordData, dictData };

        // Render details tab by default
        renderWordDetails();
      } catch (error) {
        console.error('Error loading word detail:', error);
        modalContent.innerHTML = '<p class="text-red-500">L·ªói khi t·∫£i th√¥ng tin t·ª´</p>';
      }
    }

    // Close modal
    function closeModal() {
      document.getElementById('wordModal').classList.add('hidden');
    }

    // Close modal on outside click
    document.getElementById('wordModal').addEventListener('click', (e) => {
      if (e.target.id === 'wordModal') {
        closeModal();
      }
    });
  </script>
  <script src="/js/preferences.js"></script>
  <script src="/js/progressDashboard.js"></script>
  <script src="/js/weakAreas.js"></script>
  <script src="/js/modals.js"></script>
  <script src="/js/preferencesModal.js"></script>
  <script src="/js/dashboardModal.js"></script>
</body>

</html>